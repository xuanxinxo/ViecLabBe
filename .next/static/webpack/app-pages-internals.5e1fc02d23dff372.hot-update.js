"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app-pages-internals",{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/hooks-server-context.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/hooks-server-context.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DynamicServerError: function() {\n        return DynamicServerError;\n    },\n    isDynamicServerError: function() {\n        return isDynamicServerError;\n    }\n});\nconst DYNAMIC_ERROR_CODE = \"DYNAMIC_SERVER_USAGE\";\nclass DynamicServerError extends Error {\n    constructor(description){\n        super(\"Dynamic server usage: \" + description);\n        this.description = description;\n        this.digest = DYNAMIC_ERROR_CODE;\n    }\n}\nfunction isDynamicServerError(err) {\n    if (typeof err !== \"object\" || err === null || !(\"digest\" in err) || typeof err.digest !== \"string\") {\n        return false;\n    }\n    return err.digest === DYNAMIC_ERROR_CODE;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hooks-server-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBRWFBLG9CQUFrQjtlQUFsQkE7O0lBUUdDLHNCQUFvQjtlQUFwQkE7OztBQVZoQixNQUFNQyxxQkFBcUI7QUFFcEIsTUFBTUYsMkJBQTJCRztJQUd0Q0MsWUFBNEJDLFdBQUFBLENBQXFCO1FBQy9DLEtBQUssQ0FBQywyQkFBeUJBOzJCQURMQTthQUY1QkMsTUFBQUEsR0FBb0NKO0lBSXBDO0FBQ0Y7QUFFTyxTQUFTRCxxQkFBcUJNLEdBQVk7SUFDL0MsSUFDRSxPQUFPQSxRQUFRLFlBQ2ZBLFFBQVEsUUFDUixDQUFFLGFBQVlBLEdBQUFBLEtBQ2QsT0FBT0EsSUFBSUQsTUFBTSxLQUFLLFVBQ3RCO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBT0MsSUFBSUQsTUFBTSxLQUFLSjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL2hvb2tzLXNlcnZlci1jb250ZXh0LnRzPzBhYzgiXSwibmFtZXMiOlsiRHluYW1pY1NlcnZlckVycm9yIiwiaXNEeW5hbWljU2VydmVyRXJyb3IiLCJEWU5BTUlDX0VSUk9SX0NPREUiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiZGVzY3JpcHRpb24iLCJkaWdlc3QiLCJlcnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/hooks-server-context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return OuterLayoutRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _infinitepromise = __webpack_require__(/*! ./infinite-promise */ \"(app-pages-browser)/./node_modules/next/dist/client/components/infinite-promise.js\");\nconst _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _matchsegments = __webpack_require__(/*! ./match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _notfoundboundary = __webpack_require__(/*! ./not-found-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js\");\nconst _getsegmentvalue = __webpack_require__(/*! ./router-reducer/reducers/get-segment-value */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./router-reducer/create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\n/**\r\n * Add refetch marker to router state at the point of the current layout segment.\r\n * This ensures the response returned is not further down than the current layout segment.\r\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\r\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\r\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (typeof window === \"undefined\") return null;\n    // Only apply strict mode warning when not in production\n    if (true) {\n        const originalConsoleError = console.error;\n        try {\n            console.error = function() {\n                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n                    messages[_key] = arguments[_key];\n                }\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError(...messages);\n                }\n            };\n            return _reactdom.default.findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return _reactdom.default.findDOMNode(instance);\n}\nconst rectProperties = [\n    \"bottom\",\n    \"height\",\n    \"left\",\n    \"right\",\n    \"top\",\n    \"width\",\n    \"x\",\n    \"y\"\n];\n/**\r\n * Check if a HTMLElement is hidden or fixed/sticky position\r\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        \"sticky\",\n        \"fixed\"\n    ].includes(getComputedStyle(element).position)) {\n        if (true) {\n            console.warn(\"Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:\", element);\n        }\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\r\n * Check if the top corner of the HTMLElement is in the viewport.\r\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\r\n * Find the DOM node for a hash fragment.\r\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\r\n * If the hash fragment is an id, the page has to scroll to the element with that id.\r\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\r\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === \"top\") {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args);\n        this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef, segmentPath } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler(param) {\n    let { segmentPath, children } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef,\n        children: children\n    });\n}\n_c = ScrollAndFocusHandler;\n/**\r\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\r\n */ function InnerLayoutRouter(param) {\n    let { parallelRouterKey, url, childNodes, segmentPath, tree, // isActive,\n    cacheKey } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { buildId, changeByServerResponse, tree: fullTree } = context;\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(cacheKey);\n    // When data is not available during rendering client-side we need to fetch\n    // it from the server.\n    if (childNode === undefined) {\n        const newLazyCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            parallelRoutes: new Map()\n        };\n        /**\r\n     * Flight data fetch kicked off during render and put into the cache.\r\n     */ childNode = newLazyCacheNode;\n        childNodes.set(cacheKey, newLazyCacheNode);\n    }\n    // `rsc` represents the renderable node for this segment.\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n    // We should use that on initial render instead of `rsc`. Then we'll switch\n    // to `rsc` when the dynamic response streams in.\n    //\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\n    const resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    //\n    // @ts-expect-error The second argument to `useDeferredValue` is only\n    // available in the experimental builds. When its disabled, it will always\n    // return `rsc`.\n    const rsc = (0, _react.useDeferredValue)(childNode.rsc, resolvedPrefetchRsc);\n    // `rsc` is either a React node or a promise for a React node, except we\n    // special case `null` to represent that this segment's data is missing. If\n    // it's a promise, we need to unwrap it so we can determine whether or not the\n    // data is missing.\n    const resolvedRsc = typeof rsc === \"object\" && rsc !== null && typeof rsc.then === \"function\" ? (0, _react.use)(rsc) : rsc;\n    if (!resolvedRsc) {\n        // The data for this segment is not available, and there's no pending\n        // navigation that will be able to fulfill it. We need to fetch more from\n        // the server and patch the cache.\n        // Check if there's already a pending request.\n        let lazyData = childNode.lazyData;\n        if (lazyData === null) {\n            /**\r\n       * Router state with refetch marker added\r\n       */ // TODO-APP: remove ''\n            const refetchTree = walkAddRefetch([\n                \"\",\n                ...segmentPath\n            ], fullTree);\n            childNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), refetchTree, context.nextUrl, buildId);\n        }\n        /**\r\n     * Flight response data\r\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = (0, _react.use)(lazyData);\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.lazyData = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            (0, _react.startTransition)(()=>{\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react.use)((0, _infinitepromise.createInfinitePromise)());\n    }\n    // If we get to this point, then we know we have something we can render.\n    const subtree = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        },\n        children: resolvedRsc\n    });\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n_c1 = InnerLayoutRouter;\n/**\r\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\r\n * If no loading property is provided it renders the children without a suspense boundary.\r\n */ function LoadingBoundary(param) {\n    let { children, loading, loadingStyles, loadingScripts, hasLoading } = param;\n    if (hasLoading) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    loadingStyles,\n                    loadingScripts,\n                    loading\n                ]\n            }),\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c2 = LoadingBoundary;\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey, segmentPath, error, errorStyles, errorScripts, templateStyles, templateScripts, loading, loadingStyles, loadingScripts, hasLoading, template, notFound, notFoundStyles, styles } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes, tree, url } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodesForParallelRouter = new Map();\n        childNodes.set(parallelRouterKey, childNodesForParallelRouter);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegmentValue = (0, _getsegmentvalue.getSegmentValue)(treeSegment);\n    /**\r\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\r\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        treeSegment\n    ];\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            styles,\n            preservedSegments.map((preservedSegment)=>{\n                const preservedSegmentValue = (0, _getsegmentvalue.getSegmentValue)(preservedSegment);\n                const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(preservedSegment);\n                return(/*\r\n            - Error boundary\r\n              - Only renders error boundary if error component is provided.\r\n              - Rendered for each segment to ensure they have their own error state.\r\n            - Loading boundary\r\n              - Only renders suspense boundary if loading components is provided.\r\n              - Rendered for each segment to ensure they have their own loading state.\r\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\r\n          */ /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {\n                    value: /*#__PURE__*/ (0, _jsxruntime.jsx)(ScrollAndFocusHandler, {\n                        segmentPath: segmentPath,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n                            errorComponent: error,\n                            errorStyles: errorStyles,\n                            errorScripts: errorScripts,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {\n                                hasLoading: hasLoading,\n                                loading: loading,\n                                loadingStyles: loadingStyles,\n                                loadingScripts: loadingScripts,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_notfoundboundary.NotFoundBoundary, {\n                                    notFound: notFound,\n                                    notFoundStyles: notFoundStyles,\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_redirectboundary.RedirectBoundary, {\n                                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {\n                                            parallelRouterKey: parallelRouterKey,\n                                            url: url,\n                                            tree: tree,\n                                            childNodes: childNodesForParallelRouter,\n                                            segmentPath: segmentPath,\n                                            cacheKey: cacheKey,\n                                            isActive: currentChildSegmentValue === preservedSegmentValue\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    }),\n                    children: [\n                        templateStyles,\n                        templateScripts,\n                        template\n                    ]\n                }, (0, _createroutercachekey.createRouterCacheKey)(preservedSegment, true)));\n            })\n        ]\n    });\n}\n_c3 = OuterLayoutRouter;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"OuterLayoutRouter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozt5REEwQk9BLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7dUNBQzZCQSxtQkFBQUEsQ0FBQTtpREFDRTs2Q0FDUjsyQ0FDRDs7Z0RBRUk7OENBQ0E7OENBQ0Q7O0FBR2hDLE1BQUFDLHdCQUFBRCxtQkFBQUEsQ0FBQTs7OztJQVFFLFNBQUlFLGVBQW1CQSxpQkFBQSxFQUFBQyxjQUFBO1FBQ3JCRCxtQkFBZ0JFO1FBQ2hCLE1BQU1DLENBQUFBLFNBQVNILGlCQUFrQkksR0FBQUE7UUFFakMsTUFBSUMsU0FBQUEsa0JBQUFBLE1BQWFKLEtBQUFBO1lBQ2YsSUFBSUEsZUFBZUksWUFBR0MsRUFBQUEsY0FBZUosQ0FBQUEsRUFBQUEsRUFBQUEsVUFBbUI7Z0JBQ3RERCxjQUFZLElBQUFLLGNBQUEsQ0FBQUosbUJBQUE7b0JBQ1ZDLFFBQU1JO29CQUlOLE1BQUFBLFVBQU9DLGVBQUFDLFdBQUFSLGNBQUEsSUFBQUMsaUJBQUE7MkJBQ0xEO3dCQUNBQSxjQUFBOzs0QkFFRSxHQUFDQyxjQUFBQSxDQUFpQixFQUFFOzhDQUNSO2dDQUNWSyxPQUFPLENBQUMsRUFBRTtnQ0FDVkEsT0FBTyxDQUFDLEVBQUU7Z0NBQ1ZBLE9BQUE7Z0NBQ0Q7NkJBQ0g7d0JBQ0Q7cUJBQ0g7Z0JBRUE7dUJBQ0VOO29CQUNBQSxjQUFBOzt3QkFFRSxHQUFDQyxjQUFBQSxDQUFpQixFQUFFTTt3QkFJdEIsQ0FBQU4saUJBQUEsRUFBQU0sZUFBQVIsa0JBQUFVLEtBQUEsS0FBQVQsY0FBQSxJQUFBQyxpQkFBQTtvQkFDRDtpQkFDSDtZQUNGO1FBQ0Y7SUFFQTtJQUNGLE9BQUFEO0FBRUE7QUFDQTs7O0lBTUUsU0FBQVUsWUFBQUMsUUFBQTtJQUNBLCtCQUFzQjtJQUN0QixXQUFBQyxXQUFBO0lBQ0Esd0RBQTJD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QUFBQSxHQUFBQSxpQkFBQUEsZUFBcUJDLEVBQUFBO2dCQUV0QyxNQUFBeEQsV0FDRSxJQUFBbkYsc0JBQUEwSSxvQkFBQSxFQUFBQzt1QkFXRUM7Ozs7Ozs7O3dCQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUNFQyxJQUFBLEVBQUFqRSwrQkFBQ0osZUFBQUEsQ0FBQUEsUUFBQUEsRUFBQUE7MkJBQW1DckIsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsdUJBQUFBO3FDQUNsQ0E7a0NBQ2tCbEMsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsZUFBQUEsYUFBQUEsRUFBQUE7NEJBQ2hCOEgsZ0JBQWFBOzRCQUNiQyxhQUFBQTswQ0FFQUE7c0NBQ2N2QixXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxpQkFBQUE7Z0NBQ1pDLFlBQVNBO2dDQUNURixTQUFBQTtnQ0FDQUcsZUFBQUE7Z0RBRUFBOzBDQUNZSyxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxrQkFBQUEsZ0JBQUFBLEVBQUFBO29DQUNWQyxVQUFBQTtvREFFQUE7OENBQ0Usa0JBQUFkLFlBQUFDLEdBQUEsRUFBQTZCLGtCQUFDQyxnQkFBQUEsRUFBQUE7a0RBQ29CbkUsV0FBbkJBLEdBQW1CQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxtQkFBQUE7NENBQ25CQyxtQkFBS0E7NENBQ0xFLEtBQUFBOzRDQUNBRCxNQUFBQTs0Q0FDQTlCLFlBQUFBOzRDQUNBZ0MsYUFBVUE7NENBQ1ZnRSxVQUNFZDs7Ozs7Ozs7OEJBVWZlO3dCQUNBQzt3QkFDQXRCOztxQkF2Q0lXO2dCQTBDWCxPQUFBMUksc0JBQUEwSSxvQkFBQSxFQUFBQyxrQkFBQTs7O0lBR047O01BN0gwQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLnRzeD9hYTE0Il0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX2NyZWF0ZXJvdXRlcmNhY2hla2V5Iiwic2VnbWVudFBhdGhUb1dhbGsiLCJ0cmVlVG9SZWNyZWF0ZSIsInBhcmFsbGVsUm91dGVLZXkiLCJpc0xhc3QiLCJsZW5ndGgiLCJtYXRjaFNlZ21lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInN1YlRyZWUiLCJ3YWxrQWRkUmVmZXRjaCIsInVuZGVmaW5lZCIsInNsaWNlIiwiZmluZERPTU5vZGUiLCJpbnN0YW5jZSIsIndpbmRvdyIsInByb2Nlc3MiLCJvcmlnaW5hbENvbnNvbGVFcnJvciIsImVycm9yIiwiY29uc29sZSIsIm1lc3NhZ2VzIiwiX3JlYWN0ZG9tIiwiZGVmYXVsdCIsInJlY3RQcm9wZXJ0aWVzIiwic2hvdWxkU2tpcEVsZW1lbnQiLCJlbGVtZW50IiwiaW5jbHVkZXMiLCJwb3NpdGlvbiIsIndhcm4iLCJyZWN0IiwiaXRlbSIsImV2ZXJ5IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwidmlld3BvcnRIZWlnaHQiLCJnZXRIYXNoRnJhZ21lbnREb21Ob2RlIiwiaGFzaEZyYWdtZW50IiwiYm9keSIsImRvY3VtZW50IiwiX2RvY3VtZW50X2dldEVsZW1lbnRCeUlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImNvbXBvbmVudERpZE1vdW50IiwiX3JlYWN0IiwiQ29tcG9uZW50IiwiaGFuZGxlUG90ZW50aWFsU2Nyb2xsIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiYXBwbHkiLCJyZW5kZXIiLCJwcm9wcyIsImNoaWxkcmVuIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJzZWdtZW50UGF0aCIsInNlZ21lbnRQYXRocyIsInNvbWUiLCJzY3JvbGxSZWZTZWdtZW50UGF0aCIsInNlZ21lbnQiLCJpbmRleCIsIl9tYXRjaHNlZ21lbnRzIiwiZG9tTm9kZSIsIkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIm5leHRFbGVtZW50U2libGluZyIsImhhbmRsZVNtb290aFNjcm9sbCIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJzY3JvbGxJbnRvVmlldyIsImh0bWxFbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwidG9wT2ZFbGVtZW50SW5WaWV3cG9ydCIsInNjcm9sbFRvcCIsImRvbnRGb3JjZUxheW91dCIsIm9ubHlIYXNoQ2hhbmdlIiwiZm9jdXMiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJwYXJhbSIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkVycm9yIiwicGFyYWxsZWxSb3V0ZXJLZXkiLCJ1cmwiLCJjaGlsZE5vZGVzIiwidHJlZSIsImNhY2hlS2V5IiwiYnVpbGRJZCIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJmdWxsVHJlZSIsImNoaWxkTm9kZSIsImdldCIsIm5ld0xhenlDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwic2V0IiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInVzZURlZmVycmVkVmFsdWUiLCJyZXNvbHZlZFJzYyIsInRoZW4iLCJ1c2UiLCJyZWZldGNoVHJlZSIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwibmV4dFVybCIsImZsaWdodERhdGEiLCJvdmVycmlkZUNhbm9uaWNhbFVybCIsInNldFRpbWVvdXQiLCJzdGFydFRyYW5zaXRpb24iLCJfaW5maW5pdGVwcm9taXNlIiwiY3JlYXRlSW5maW5pdGVQcm9taXNlIiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJzdWJ0cmVlIiwibG9hZGluZ1N0eWxlcyIsImhhc0xvYWRpbmciLCJsb2FkaW5nIiwibG9hZGluZ1NjcmlwdHMiLCJmYWxsYmFjayIsIlN1c3BlbnNlIiwiT3V0ZXJMYXlvdXRSb3V0ZXIiLCJ0ZW1wbGF0ZSIsIm5vdEZvdW5kIiwibm90Rm91bmRTdHlsZXMiLCJzdHlsZXMiLCJjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIiLCJ0cmVlU2VnbWVudCIsImN1cnJlbnRDaGlsZFNlZ21lbnRWYWx1ZSIsIl9nZXRzZWdtZW50dmFsdWUiLCJnZXRTZWdtZW50VmFsdWUiLCJwcmVzZXJ2ZWRTZWdtZW50cyIsInByZXNlcnZlZFNlZ21lbnRWYWx1ZSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwicHJlc2VydmVkU2VnbWVudCIsInZhbHVlIiwianN4cyIsImVycm9yQ29tcG9uZW50IiwiZXJyb3JTdHlsZXMiLCJlcnJvclNjcmlwdHMiLCJfcmVkaXJlY3Rib3VuZGFyeSIsIklubmVyTGF5b3V0Um91dGVyIiwiaXNBY3RpdmUiLCJ0ZW1wbGF0ZVN0eWxlcyIsInRlbXBsYXRlU2NyaXB0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/static-generation-bailout.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/static-generation-bailout.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isStaticGenBailoutError: function() {\n        return isStaticGenBailoutError;\n    },\n    staticGenerationBailout: function() {\n        return staticGenerationBailout;\n    }\n});\nconst _hooksservercontext = __webpack_require__(/*! ./hooks-server-context */ \"(app-pages-browser)/./node_modules/next/dist/client/components/hooks-server-context.js\");\nconst _staticgenerationasyncstorageexternal = __webpack_require__(/*! ./static-generation-async-storage.external */ \"(shared)/./node_modules/next/dist/client/components/static-generation-async-storage.external.js\");\nconst NEXT_STATIC_GEN_BAILOUT = \"NEXT_STATIC_GEN_BAILOUT\";\nclass StaticGenBailoutError extends Error {\n    constructor(...args){\n        super(...args);\n        this.code = NEXT_STATIC_GEN_BAILOUT;\n    }\n}\nfunction isStaticGenBailoutError(error) {\n    if (typeof error !== \"object\" || error === null || !(\"code\" in error)) {\n        return false;\n    }\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\n}\nfunction formatErrorMessage(reason, opts) {\n    const { dynamic, link } = opts || {};\n    const suffix = link ? \" See more info here: \" + link : \"\";\n    return \"Page\" + (dynamic ? ' with `dynamic = \"' + dynamic + '\"`' : \"\") + \" couldn't be rendered statically because it used `\" + reason + \"`.\" + suffix;\n}\nconst staticGenerationBailout = (reason, param)=>{\n    let { dynamic, link } = param === void 0 ? {} : param;\n    const staticGenerationStore = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();\n    if (!staticGenerationStore) return false;\n    if (staticGenerationStore.forceStatic) {\n        return true;\n    }\n    if (staticGenerationStore.dynamicShouldError) {\n        throw new StaticGenBailoutError(formatErrorMessage(reason, {\n            link,\n            dynamic: dynamic != null ? dynamic : \"error\"\n        }));\n    }\n    const message = formatErrorMessage(reason, {\n        dynamic,\n        // this error should be caught by Next to bail out of static generation\n        // in case it's uncaught, this link provides some additional context as to why\n        link: \"https://nextjs.org/docs/messages/dynamic-server-error\"\n    });\n    // If postpone is available, we should postpone the render.\n    staticGenerationStore.postpone == null ? void 0 : staticGenerationStore.postpone.call(staticGenerationStore, reason);\n    // As this is a bailout, we don't want to revalidate, so set the revalidate\n    // to 0.\n    staticGenerationStore.revalidate = 0;\n    if (staticGenerationStore.isStaticGeneration) {\n        const err = new _hooksservercontext.DynamicServerError(message);\n        staticGenerationStore.dynamicUsageDescription = reason;\n        staticGenerationStore.dynamicUsageStack = err.stack;\n        throw err;\n    }\n    return false;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=static-generation-bailout.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFXZ0JBLHlCQUF1QjtlQUF2QkE7O0lBeUJIQyx5QkFBdUI7ZUFBdkJBOzs7Z0RBbENzQjtrRUFDVTtBQUU3QyxNQUFNQywwQkFBMEI7QUFFaEMsTUFBTUMsOEJBQThCQzs7O2FBQ2xCQyxJQUFBQSxHQUFPSDs7QUFDekI7QUFFTyxTQUFTRix3QkFDZE0sS0FBYztJQUVkLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsQ0FBRSxXQUFVQSxLQUFBQSxHQUFRO1FBQ3JFLE9BQU87SUFDVDtJQUVBLE9BQU9BLE1BQU1ELElBQUksS0FBS0g7QUFDeEI7QUFTQSxTQUFTSyxtQkFBbUJDLE1BQWMsRUFBRUMsSUFBa0I7SUFDNUQsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRSxHQUFHRixRQUFRLENBQUM7SUFDbkMsTUFBTUcsU0FBU0QsT0FBTywwQkFBd0JBLE9BQVM7SUFDdkQsT0FBTyxTQUNMRCxDQUFBQSxVQUFVLHVCQUFzQkEsVUFBUSxPQUFPLE1BQ2hELHVEQUFxREYsU0FBTyxPQUFLSTtBQUNwRTtBQUVPLE1BQU1YLDBCQUFtRCxDQUM5RE8sUUFBQUE7UUFDQSxFQUFFRSxPQUFPLEVBQUVDLElBQUksRUFBRSxHQUFBRSxVQUFBLFNBQUcsQ0FBQyxJQUFBQTtJQUVyQixNQUFNQyx3QkFBd0JDLHNDQUFBQSw0QkFBNEIsQ0FBQ0MsUUFBUTtJQUNuRSxJQUFJLENBQUNGLHVCQUF1QixPQUFPO0lBRW5DLElBQUlBLHNCQUFzQkcsV0FBVyxFQUFFO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlILHNCQUFzQkksa0JBQWtCLEVBQUU7UUFDNUMsTUFBTSxJQUFJZixzQkFDUkksbUJBQW1CQyxRQUFRO1lBQUVHO1lBQU1ELFNBQVNBLFdBQUFBLE9BQUFBLFVBQVc7UUFBUTtJQUVuRTtJQUVBLE1BQU1TLFVBQVVaLG1CQUFtQkMsUUFBUTtRQUN6Q0U7UUFDQSx1RUFBdUU7UUFDdkUsOEVBQThFO1FBQzlFQyxNQUFNO0lBQ1I7SUFFQSwyREFBMkQ7SUFDM0RHLHNCQUFzQk0sUUFBUSxvQkFBOUJOLHNCQUFzQk0sUUFBUSxDQUFBQyxJQUFBLENBQTlCUCx1QkFBaUNOO0lBRWpDLDJFQUEyRTtJQUMzRSxRQUFRO0lBQ1JNLHNCQUFzQlEsVUFBVSxHQUFHO0lBRW5DLElBQUlSLHNCQUFzQlMsa0JBQWtCLEVBQUU7UUFDNUMsTUFBTUMsTUFBTSxJQUFJQyxvQkFBQUEsa0JBQWtCLENBQUNOO1FBQ25DTCxzQkFBc0JZLHVCQUF1QixHQUFHbEI7UUFDaERNLHNCQUFzQmEsaUJBQWlCLEdBQUdILElBQUlJLEtBQUs7UUFFbkQsTUFBTUo7SUFDUjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXQudHM/YzFkMyJdLCJuYW1lcyI6WyJpc1N0YXRpY0dlbkJhaWxvdXRFcnJvciIsInN0YXRpY0dlbmVyYXRpb25CYWlsb3V0IiwiTkVYVF9TVEFUSUNfR0VOX0JBSUxPVVQiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJFcnJvciIsImNvZGUiLCJlcnJvciIsImZvcm1hdEVycm9yTWVzc2FnZSIsInJlYXNvbiIsIm9wdHMiLCJkeW5hbWljIiwibGluayIsInN1ZmZpeCIsInBhcmFtIiwic3RhdGljR2VuZXJhdGlvblN0b3JlIiwic3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwiZm9yY2VTdGF0aWMiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJtZXNzYWdlIiwicG9zdHBvbmUiLCJjYWxsIiwicmV2YWxpZGF0ZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImVyciIsIkR5bmFtaWNTZXJ2ZXJFcnJvciIsImR5bmFtaWNVc2FnZURlc2NyaXB0aW9uIiwiZHluYW1pY1VzYWdlU3RhY2siLCJzdGFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/static-generation-bailout.js\n"));

/***/ })

});